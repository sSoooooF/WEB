### Асинхронность и блокировки сокета.
Во время ввода/вывода происходит обмен пакетами по сети и вся сопутствующая тяжелая низкоуровневая работа. При этом процессор не может остановиться, он продолжает делать такты, не исполняя никаких инструкций, просто зря потребляя энергию. Для того, чтобы делать в этот момент что-то полезное используется **асинхронность**.

Методы accept(), connect() и recv() класса socket являются блокирующими. Это значит, что после их вызова выполнение программы остановится и не возобновится до тех пор, пока не поступят соответствующие данные из сети. А если программа не выполняется, то и другие соединения, и задачи также не обрабатываются.
Также соединение не закрывается сразу после выдачи ответа, а выполняется в бесконечном цикле, пока сам пользователь не выйдет из программы. Это значит, что сервер может обрабатывать вообще только одно соединение за раз.
### Многопоточный и многопроцессный сокет
Для реализации асинхронности используется **многопоточные** (потоки выполняются в одном процессе) и **многопроцессные** (создаются копии самого процесса приложения).

**Процессы** — это процессы операционной системы (ОС). Запуск нового процесса можно сравнить с делением живой клетки. Сначала копируется интерпретатор, все окружение и текущее состояние памяти, а потом выполнение продолжается с того же места, но уже в двух разных процессах. Если мы посмотрим в менеджере задач ОС список процессов, то можем увидеть, что их число увеличилось на единицу. На Unix-системах процесс можно создать системным вызовом fork. В результате появляется два одинаковых процесса вместо одного, но с разными pid (process id).
