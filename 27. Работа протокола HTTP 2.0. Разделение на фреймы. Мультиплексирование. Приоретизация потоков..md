### Работа протокола HTTP 2.0.


### Разделение на фреймы

### Мультиплексирование
Современный сайт обычно работает так: отправляется первый GET-запрос → он возвращает клиенту HTML-страницу → она подключает дополнительные ресурсы: js-файлы, css-таблицы, картинки, шрифты. После загрузки всех (или почти всех) ресурсов сайт становится интерактивным для пользователя.

В HTTP/1.0 для загрузки каждого ресурса устанавливалось новое TCP/IP соединение. HTTP/1.1 принёс keep-alive, который позволил загружать множество ресурсов в рамках одного соединения. Это значительно увеличило производительность протокола. Однако, ресурсы загружаются последовательно (waterfall): нельзя получить следующий ресурс, пока не получен предыдущий.

Когда запрос к ресурсу подвисает из-за сложностей с его получением, возникает проблема Head-Of-Line Blocking. Это означает, что зависший запрос блокирует отправку всех остальных, так как обработка идёт в порядке очереди. Новая структура передачи данных в бинарном формате дала возможность загружать несколько ресурсов параллельно.

Теперь вся информация при передаче бьётся на небольшие бинарные кусочки — фреймы. Они собираются в потоки, для каждого запрашиваемого ресурса создаётся отдельный. При этом все фреймы от разных потоков могут передаваться вперемешку в одном TCP/IP соединении. Принимающая сторона самостоятельно соберёт все фреймы из одного потока и обработает их. Также клиент теперь может прервать получение одного потока, не закрывая соединение.

### Приоретизация потоков
Механизм приоритизации потоков позволяет управлять порядком обработки и передачи потоков данных на одном соединении. Он улучшает производительность, делает управление ресурсами эффективнее, позволяет гибко контролировать рендеринг страницы.

При отправке параллельных запросов на сервер клиент может расставить приоритеты запрашиваемых им ответов. Это делается присвоением каждому потоку веса от 1 до 256. Чем выше вес, тем выше приоритет. Потоки могут быть связаны с ресурсами на сервере: изображениями, CSS-файлами, HTML-страницами и другими.

Сервер использует эту информацию, управляет потоками данных и определяет порядок их обработки. Например, он может начать обработку потока с более высоким приоритетом, даже если это не первый поток, который был отправлен. Помимо этого клиент может указывать зависимости между потоками.