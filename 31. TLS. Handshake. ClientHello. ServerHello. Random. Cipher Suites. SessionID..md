### TLS
Протокол TLS (transport layer security) основан на протоколе SSL (Secure Sockets Layer), изначально разработанном в Netscape для повышения безопасности электронной коммерции в Интернете. Протокол TLS реализован непосредственно над TCP (Transmission Control Protocol), что позволяет более высокоуровневым протоколам (таким как HTTP или протоколу электронной почты) работать без изменений. TLS ставит своей целью создание между двумя узлами сети защищённого от прослушивания и подмены информации канала связи, пригодного для передачи произвольных данных в обоих направлениях, а также проверку того, что обмен данными происходит между именно теми узлами, для которых канал и планировался.

TLS работает с записями (records). Записи находятся в фундаменте протокола. Это нижний транспортный уровень TLS. Сообщения TLS, относящиеся к верхним уровням, могут быть разбиты на несколько записей. Если рассматривать сеанс TLS на уровне условного сокета (TCP), то каждая передаваемая TLS-запись представляет собой блок, состоящий из короткого заголовка и, собственно, самих данных.

### Handshake
Клиент и сервер должны договориться об используемых шифрах и методах аутентификации, согласовать ключи и другие параметры сеанса связи. Набор согласованных параметров называется криптографическим контекстом. Согласование происходит при установлении соединения, путём обмена специальными сообщениями - handshake-сообщениями.

### ClientHello
Первым сообщением в протоколе установления TLS-соединения всегда является сообщение ClientHello. Сообщение содержит следующие данные:
1. версию протокола - максимальную версию, которую готов поддерживать клиент;
2. 32 байта случайных значений - Client Random. Изначально, в спецификации рекомендовалось использовать первые 4 байта для передачи UNIX-таймстемпа, а оставшиеся 28 - заполнять результатом работы криптографического генератора псевдослучайных чисел. Однако сейчас многие браузеры и веб-серверы генерируют все 32-байта случайным образом.
3. идентификатор TLS-сессии - SessionID: TLS позволяет возобновлять ранее установленные сессии, используя сокращённый вариант протокола установления соединения. Идентификатор сессии как раз содержит номер такой сессии, параметры которой (возможно) сохранены на сервере.
4. список шифров наборов, которые поддерживает клиент - Cipher Suites. Порядок шифронаборов в списке отражает их степень предпочтения клиентом (предпочтительные передаются первыми), этот порядок - всего лишь рекомендация, и сервер далеко не всегда ей следует;
5. список поддерживаемых методов сжатия - Compression Methods.
6. данные нескольких расширений протокола.

### ServerHello
Согласно спецификации, после отправки ClientHello, клиент ожидает ответа сервера. В ответ может прийти либо сообщение об ошибке, в виде Alert, либо сообщение ServerHello.

Если сервер смог успешно обработать ClientHello, то он отвечает сообщением ServerHello. Это сообщение так же имеет заголовок из четырёх байтов: тип сообщения (один байт) и длина (три байта). ServerHello (здесь мы рассматриваем версии до 1.3) содержит следующие поля:
1) версию протокола, которую будут использовать клиент и сервер;
2) 32 байта случайных значений - ServerRandom. С этой строкой ситуация такая же, как и с Client Random: первые четыре байта могут быть таймстемпом, а могут и не быть. Интересным свойством данной метки времени является то, что она может послужить некоторым справочным материалом при последующем анализе записанного трафика: если сервер отвечает достоверным значением времени, то, учитывая, что полный набор сообщений Handshake содержит сообщение, криптографически удостоверяющее целостность данных, получаем подписанную сервером квитанцию о времени соединения по его часам, с точностью до секунды - иногда эти данные помогают правильно составить запрос в адрес администрации сервера об извлечении записей из логов;
3) идентификатор сессии - SessionID, присвоенный новой сессии сервером;
4) выбранный сервером шифронабор - Cipher Suite, этот шифронабор будет использоваться в дальнейшем и клиентом, и сервером. Сервер выбирает шифронабор из предложенных клиентом в ClientHello, но не обязательно следует приоритету клиента.
5) выбранный сервером метод сжатия - скорее всего, это null;
6) некоторый набор расширений.