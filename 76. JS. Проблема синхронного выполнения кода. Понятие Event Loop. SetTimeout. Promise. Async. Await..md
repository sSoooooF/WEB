### JS
[[73. JS. Переменные и типы JS. Стандартные процедуры JS]]

### Проблема синхронного выполнения кода
Идея такая: есть главный код, который выполняется – main-поток. Если бы весь код был в main-потоке без асинхронных операций, то чтобы убрать ожидание (например, при обращении к БД и ожидании от нее ответа), мы делаем от main отдельный поток. То есть main выполняет код, а в потоке есть БД и ответ от нее. Ответ будет применен только тогда, когда весь код всей синхронной операции выполнится. То есть сначала выполняем все синхронные операции, а потом забираем этот ответ, когда БД дала его. А что если кусок основного кода или какая-то еще функция должна выполниться после ответа от БД? И что если там есть еще какой-то 2-ой запрос к БД? Если мы его перенесем также в отдельный поток, то окажется проблема: то мы код в первом потоке выполнили, ушли в асинхронность, а код, который за ним, когда выполнять? Придется его писать в потоке 2.

### Понятие Event Loop
Eventloop в JavaScript — менеджер асинхронных вызовов.
Чтобы этот хитрый процесс слаженно работал, в JavaScript реализован механизм для управления очерѐдностью исполнения кода. Поскольку это однопоточный язык, возникла необходимость «вклиниваться» в текущий контекст исполнения. Этот механизм называется eventloop — событийный цикл. С английского loop переводится как «петля», что отлично отражает смысл: мы имеем дело с закольцованной очередью.

![[Pasted image 20241224234426.png]]

### SetTimeout
Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».Для этого существуют два метода: setTimeout позволяет вызвать функцию **один раз** через определѐнный интервал времени. setInterval позволяет вызывать функцию **регулярно**, повторяя вызов через определѐнный интервал времени. Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.

### Promise
Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода. Promise – это специальный объект, который содержит своѐ состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
Способ использования, в общих чертах, такой:
1. Код, которому надо сделать что-то асинхронно, создаѐт объект promise и возвращает его.
2. Внешний код, получив promise, навешивает на него обработчики.
3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
Существует специальный синтаксис для работы с промисами, который называется «async/await».

### Async. Await.
**async** ставится перед функцией. У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически. Ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернѐт промис.
Ключевое слово **await** заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернѐт его результат, и выполнение кода продолжится. Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

